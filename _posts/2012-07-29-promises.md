---
title: Micro-problem
layout: post
published: false
---

As more web apps support customizing their experience using third-party APIs like Facebook/Twitter, they eventually have to deal with the problem of permission tiers. This is more prevalent with a Facebook integration specifically, where there is a high granularity to the permissions a user can grant an app.

What We Want
============

{% highlight js %}

	ensureAuthenticated(['publish_actions'], function() {
		// user is guarnateed authenticated w/ `publish_actions` permission
		publishOGPAction();
	});

{% endhighlight }

What are the issues we have to address?

1. New users should be prompted for an authentication dialog before the action proceeds. This can be a little tricky because it requires popping a dialog box, which means we must not leave the event loop before the dialog invocation, or the browser will block the popup.
2. Existing users that do not have the permission should be prompted for the extended permission. Again, must deal with the dialog opening for this.
3. Existing users that have already granted the permission should just pass through; no side effects like a dialog opening should happen.

Using FB Authentication
=======================

Knowing if the user is logged in via the FB SDK is trivial; knowing if they have granted access to permissions is a different story.

- GET /me/permissions (requires valid access_token)

The Use Case
============

Let's say, for example, you have a button in your web app to save an item to a "Favorite" or "Loved" list - a pretty common app convention. Furthermore, it is a business requirement that clicking this button also publishes OGP action to the user's Facebook Timeline - in order to do that, you need that user to authenticate your app to their data. It used to be the case that you also need to ask for a specific permission - `publish_actions` - in order to post to a user's Timeline. For the sake of this exercise, let's assume that's still the case, so your app requires two separate authentication levels from the user.

Now, in any Facebook integration that involves getting permissions from a user, there are two basic steps your app must perform. A call to FB.init must be included on your page somewhere where it can run after the FB SDK has loaded onto your client page, and you must include a FB.login call wherever you are requiring new permissions from the user. This would probably look something like this:

{% highlight js %}

FB.login(function(response) {
	if (response.authResponse) {
		// user accepted
		FB.api('/me/permissions', function(response) {
			// double-check
			if (! response || "error" in response) {
				// error
			}
		});
	} else {
		// did not accept
	}
}, {
	scope: 'publish_actions'
});

{% endhighlight %}

Refactoring
===========

Our above example will get the job done. However, there are a few things that suck, both from the user's experience and the developer's experience. For the user, we can break it down easily into a few stories.

1. As a user, I don't want to see a popup window every time I click a 'favorite' button
2. As a user, I don't want to see a popup window _ever_ if I've already granted permissions
3. As a user, I want to see a popup auth dialog if I have authenticated, but not granted permissiont to post to my Timeline

For the developer, we want to write our code so that we are not coupling our UI logic with business logic handling the user's permissions. This will enable us to break off the user permission code, making it easier to unit test and easier to reuse throughout our application. Future developers should not have to solve this problem again.

Isolate functionality behind interface
--------------------------------------

{% highlight js %}

FB.login(function(response) {
	if (response.authResponse) {
		// user auth'd, but did they accept permissions?
		FB.api('/me/permissions', function(r) {

		});
	} else {
		// user not auth'd
	}
}, {
	scope: 'email,user_location'
});

{% endhighlight %}

We have now trivially moved the code into a subroutine that provides its own abstrations into the success / failure state of the permissions request. We've broken a bit of the dependency on the FB SDK from the UI handling code and also generalized the pattern for handling a successful auth response versus a failure case.

Locally cache permission state
------------------------------

{% highlight js %}

var askForPermissions = (function() {
	// will be storing the current permission state of user as array of permissions
	// `null` = user not authenticated OR we don't know permission state yet
	var permsGranted = null;

	function hasGrantedPerms(perms) {
		var i = 0; perm,
			permsRequsted;
		// convert to array
		permsRequested = [].concat(perms);
		// user not authed or don't know perms
		if (! permsGranted) return false;
		// check each perm against cached list
		for (; perm = permsRequested[i++]; ) {
			if (permsGranted.indexOf(perm) < 0) return false;
		}
		return true;
	}

	// @param {Array} perms
	return function askForPermissions(perms, onSuccess, onError) {
		if (hasGrantedPerms(perms)) return onSuccess();

		FB.login(function(response) {
			if (response.authResponse) {
				// write back to local cache (additive)
				permsGranted = (permsGranted || []).concat(perms);
				onSuccess();
			} else {
				onError();
			}
		}, {
			// facebook expects comma-separated values (no whitespace)
			scope: perms.join(',')
		});
	}
})();

$('.favorite-button').click(function(event) {
	askForPermissions(['publish_actions'], doFavorite);
});

{% endhighlight %}

It ended up being easier to treat permissions as an array structure instead of keeping it as a comma-separated string. The askForPermissions function now requires the `perms` argument be an array as a result. I also started encapsulating more business logic around the permission handling within its own closure scope, only exposing the public function that we want to make available.

Now we've at least solved the problem of popping the auth dialog up in the user's face every time they click the button. However, there's still the problem of knowing what permissions they've allowed when the page loads. Ideally we should be able to 'just know' the user's permission status and not show an auth popup if they've already granted all required permissions. Let's add some extra client code to prime our permission state when the page loads.

Prime cache on page load
------------------------

{% highlight js %}

var askForPermissions = (function() {
	var permsGranted = null;

	// ...

	$(function() {
		FB.api('/me/permissions', function(response) {
			if (! 'data' in response) return;

			// data comes back in key/val mapping;
			// keys = permission names,
			// values = granted status (1 = granted, 0 = not)
			for (var permName in response.data) {
				if (response.data.hasOwnProperty(permName)
					&& response.data[permName]) {
					permsGranted.push(permName);
				}
			}
		});
	});

	return function askForPermissions(perms, onSuccess, onError) {
		// ..
	};
})();

{% endhighlight %}

I left out the bits we've already worked through. Now we have a routine that fetches the permissions from Facebook's API and will cache them into the closure scope if we find some valid ones.

Putting it all together
-----------------------

