---
title: "Making OpenID Keystone Federation Fancier"
series: OpenStack Dev Stories
layout: post
toc: true
---

At [Chameleon](https://www.chameleoncloud.org), I help develop and operate a
series of OpenStack cloud deployments, which have been modded to serve as a
powerful general-purpose testbed for Computer Science research.

In the middle of 2020 we worked to replace our old legacy authentication and
identity system. Users up until that time had to register for a separate account
for Chameleon, and we had various automated systems in place to try to sync
their Chameleon accounts with their various OpenStack Keystone users across our
multiple cloud deployments. We also played with running a distributed MariaDB
cluster just for [Keystone](https://docs.openstack.org/keystone/latest/) in
order to transparently share user accounts between multiple cloud sites, but
this proved difficult to maintain and clunky in practice: each Keystone DB ran
at a completely seperate host institution / datacenter and the cluster as a
whole was thus exposed to high numbers of maintenance or outage events,
replication broke often because we were not able to effectively prevent
conflicting writes to critical Keystone tables on the replicas, and the approach
was difficult to scale past two sites due to the difficulty in ensuring secure
performant networking between all nodes over the WAN.

It was time for a change. We wanted a system that was simpler for users to use
and be onboarded into, while also scaling well to arbitrary numbers of cloud
deployment sites. Federated identity provided the solution, but it took some
hacking to get us there.

## Product definition

There are a few important rules about Chameleon accounts from the identity
system's perspective:

1. Users are organized into projects.
2. A user can be a member of multiple projects.
3. Projects can transition between an enabled and disabled state depending on
   if the project is authorized to continue using Chameleon resources.
4. Users can also transition between an enabled and disabled state, e.g.,
   if the user is suspended for infractions agains the terms of use.

Given this, we had the following aims:

**Users should be able to log in with existing credentials.** Chameleon caters
to the research community, many of whom already have accounts at their host
institution or national laboratory. For those who do not have such accounts, we
would support a general-purpose identity such as Google or
[ORCiD](https://orcid.org).

**A user's login session should carry across applications.** Prior, users of
Chameleon's various OpenStack clouds would have to log in to each cloud
separately, though with the same credentials. Single Sign-On (SSO) makes sense
to use for our systems and is a better user experience.

**Users who are part of no enabled projects can still log in.** When a user
first joins Chameleon, they will likely not be a part of any projects.
Similarly, if returning after a long time, it's possible their pre-existing
projects have expired. We needed to be able to gracefully handle this case so we
could communicate the state of the user's account to them. These "orphan" users
should also still be allowed to use any aspect of the site not requiring project
membership (like updating their contact details.)

**Users should not be allowed to perform actions under disabled projects.**
This is somewhat obvious, but important enough to call out, as it's how we
prevent unauthorized usage of cloud resources.

**CLI/API authentication must be supported.** Many users use CLI interfaces to
Chameleon's cloud systems and we had to ensure we did not break this or make it
significantly more onerous. If you've used OpenStack's clients before, you know
how burdensome figuring out the right authentication parameters can already be.

## A brief guide to Keystone federation

[Keystone's own
documentation](https://docs.openstack.org/keystone/latest/admin/federation/introduction.html#what-is-keystone-federation)
will do a far better job than I of explaining what federated identity is in
general, and how Keystone supports it. The main thing to know is that Keystone
supports registering a _mapping_, expressed as a JSON file following a defined
schema, which describes how [OIDC](https://openid.net/connect/) or
[SAML](https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=security)
claims should map to Keystone entities. A claim is some metadata that is
attached to the authentication token generated by the identity provider, and
typically has some basic information about the user, such as their username,
email address, and possibly other contact details. The specifics are ultimately
up to the identity provider. This means that if you control the identity
provider implementation, you have a lot of options open to you.

In the simplest case, all the Keystone projects are assumed to be configured
prior to any user logging in, and Keystone merely adds them to the appropriate
project on first login. Keystone additionally has limited support for
_auto-provisioning_ projects, which means the cloud operator has to do very
little work ahead of time, and indeed, doesn't need to do additional work for
any additional future projects/groups. This can however cause difficulties if
projects which were never intended to wind up in Keystone get auto-provisioned,
so some care must be taken to filter these out.

Here is a simple mapping, just so you have an idea. It will create a federated
user in Keystone named "{FirstName} {LastName}" with the email "{Email}", where
those bracketed parts would be resolved from the OIDC or SAML claims. For every
group in the OIDC_GROUPS claim, the user will be added to a group of that name
(the group must already exist in Keystone.)

<!-- prettier-ignore -->
{% highlight json %}
{
  "rules": [
    {
      "local": [
        {
          "user": {
            "name": "{0} {1}",
            "email": "{2}"
        },
        "group": {
            "name": "{3}",
            "domain": {
              "id": "default"
            }
          }
        }
      ],
      "remote": [
        {
          "type": "FirstName"
        },
        {
          "type": "LastName"
        },
        {
          "type": "Email"
        },
        {
          "type": "OIDC_GROUPS"
        }
      ]
    }
  ]
}
{% endhighlight %}

Rather than directly integrate Keystone with a third-party identity provider,
such as GitHub, or Google, or [Globus](https://globus.org), we decided to deploy
and configure our own intermediate identity provider using
[Keycloak](https://www.keycloak.org). This ended up being a very good decision
because it allowed us to reap the benefits of upstream identity providers such
as Globus while being able to control how claims were delivered downstream to
our Keycloak clients. For example, we were able to model all Chameleon projects
as Keycloak groups, with an additional group attribute indicating whether the
project was enabled. We then could write a custom OIDC claim provider that
returned the precise list of groups that the authenticating user was a member
of, and filter that list to only include enabled projects.

## The missing pieces

After evaluating Keystone's federation offering, it became clear that we would
have some troubles. Fortunately, and it's a testament to Keystone's design that
I was able to do this, all blockers were resolved with relatively minimal
changes or modifications to Keystone, and in all cases we were adding new
functionality to Keystone rather than making breaking changes to existing
functionality. These kind of changes are easier to carry forward into future
OpenStack releases even if they are not accepted by core contributors.

In all cases, I tried to structure the solution to our problem such that it
addressed as wide a set of use cases as possible, rather than doing one-off
hacks just for our deployment. While more difficult, the hope is this improves
the chances of us releasing the patches upstream.

### Multiple projects per user

The first thing I noticed was that auto-provisioning of projects didn't work
quite like I expected. In the following simple mapping, consider a test user
that has OIDC claims like this:

<!-- prettier-ignore -->
{% highlight json %}
{
  "preferred_username": "jason@example.com",
  "projects": ["MyProject", "MyOtherProject"]
}
{% endhighlight %}

With the following mapping, I would expect this user is added to two projects,
one called MyProject and one called MyOtherProject, and each project would be
lazily created if it did not already exist.

<!-- prettier-ignore -->
{% highlight json %}
{
  "rules": [
    {
      "local": [
        {
          "user": {
            "name": "{0}"
          }
        },
        {
          "projects": [
            {
              "name": "{1}",
              "roles": {
                "name": "member"
              }
            }
          ]
        }
      ],
      "remote": [
        {
          "type": "OIDC-preferred_username"
        },
        {
          "type": "OIDC-projects"
        }
      ]
    }
  ]
}
{% endhighlight %}

This however was not the case! Instead, a single project was created, with
the entire list of project names encoded as the name field:

<!-- prettier-ignore -->
{% highlight shell %}
+-------------+----------------------------------+
| Field       | Value                            |
+-------------+----------------------------------+
| description |                                  |
| domain_id   | b5bb9d8014a0f9b1d61e21e796d78dcd |
| enabled     | True                             |
| id          | 1352f23cd32812f4850b878ae494af78 |
| is_domain   | False                            |
| name        | ["MyProject","MyOtherProject"]   |
| options     | {}                               |
| parent_id   | b5bb9d8014a0f9b1d61e21e796d78dcd |
| tags        | []                               |
+-------------+----------------------------------+
{% endhighlight %}

This turned out to be because not all mapping "targets" in Keystone's
federation mapping could support the input being a list. When the input claim
is a list, the desired behavior is to expand the list, mapping to N targets
instead of 1.

The patch for this,
[keystone/727891](https://review.opendev.org/c/openstack/keystone/+/727891),
ended up a bit more complicated, because it also added the missing support for
mapping multiple role names. We did not need support for mapping multiple roles,
as all users just get the default "member" role on their projects, but it was
simple enough to make it worthwhile to have the consistency.

### More regex support

### Auto-remove users

It turns out that, while users can be added to projects lazily on first login,
they are never removed from these projects if their claims change later! This
was important to fix, because it meant that users would retain access to any
of their past projects forever.

[keystone/741785](https://review.opendev.org/c/openstack/keystone/+/741785) adds
a new Keystone configuration setting `remove_dangling_assignments`, which is
turned off by default to maintain old behavior. If turned on, however, users
will be removed from any projects not matching their claims. This only applies
to projects within the identity provider domain (so, any projects in other
domains or the default domain will be untouched).

### Rich claim objects

Keystone reasonably assumes that claims are going to either be strings, or
lists of strings. We however had a very specific need, and while it's a bit of
a silly need relative to the technical complexity required to fulfill it, it
ultimately drove a few improvements that make the Keystone mapping engine
significantly more powerful.

#### Motivation

When users are logged in to the OpenStack GUI, in the top nav bar they have a
project selector dropdown, which displays the name of the project. In Chameleon,
all of our projects have immutable names--this is important because the names
act as foreign keys, allowing projects to be matched up across cloud
deployments. These names are however not very user-friendly: they look like a
prefix followed by a set of 6 numbers. Users who are members of multiple
projects very often get them confused. So, at some point we added support for
displaying the project's "nickname" in this field; we stored the nickname as an
additional extra field on the project entity (Keystone already supported this.)
We then patched the GUI to show that field value if it was present. Users were
glad to have it.

With federated projects being auto-provisioned, we had to somehow sneak that
nickname field in there. We could have opted to periodically sync the nickname
directly to the project via some out-of-band process, but we had come this far
without having to fall back on syncing, and one of the design goals of the
architecture was to avoid this. So, what can we do?

The first step was to update our Keycloak IdP to return a more complex
representation for the projects a user belonged to:

<!-- prettier-ignore -->
{% highlight json %}
{
  "preferred_username": "jason@example.com",
  "projects": [
    {"name": "P-123456", "nickname": "MyProject"},
    {"name": "P-234567", "nickname": "OtherProject"}
  ]
}
{% endhighlight %}

So now instead of having the "projects" claim be a list of IDs/names, we have
a richer representation containing both. Now we have to get Keystone to accept
this new reality.

#### Parsing entire assertion as JSON

Keystone delegates the authentication and authorization to some service sitting
directly in front of Keystone. That service is responsible for doing all the
handshakes and claim verification, before passing the claims to the Keystone
wsgi handler. Keystone then sees those claims as environment variables or HTTP
headers. For OpenID, the `mod_auth_openidc` Apache module is the recommended
solution for this. Now, when using a richer claim structure, the first thing I
noticed was that the claim wasn't being properly passed down to Keystone,
because the Apache module couldn't understand how to parse and then re-serialize
the claim; it was not expecting a nested JSON structure.

The solution to this was to configure the module to just pass all the claims
directly through to Keystone in a big JSON blob. This is possible by changing
the
"[OIDCPassIDTokenAs](https://github.com/zmartzone/mod_auth_openidc/blob/276bdafdb241bd88cb1069035df79e23ef4a0ada/auth_openidc.conf#L748)"
`mod_auth_openidc` setting from "claims" to "claims payload", meaning that both
the individual claims are passed as environment/headers, but also one
environment variable will contain the entire payload encoded as JSON.

I then wrote a little patch (not yet submitted) to add a new `assertion_payload`
configuration setting, which can be set to the name of the environment variable
that will hold the entire set of claims encoded as JSON. Keystone will then
parse the value of that variable as JSON and update its internal representation
of the assertion claims accordingly. This allowed the rich claims to make it
into the mapping engine.

#### Mapping "extra" properties

Next, the "projects" mapper needed support for actually specifying this "extra"
metadata to set on the project when it was created. Another patch adds support
for this in the mapping engine, allowing you to specify an "extra" field in a
project mapper to set additional fields:

<!-- prettier-ignore -->
{% highlight json %}
{
  "rules": [
    {
      "local": [
        {
          "user": {
            "name": "{0}"
          }
        },
        {
          "projects": [
            {
              "name": "{1}",
              "extra": {
                "extra-key": "extra-value",
                "extra_key2": "extra-value2"
              },
              "roles": {
                "name": "member"
              }
            }
          ]
        }
      ],
      "remote": [
        {
          "type": "OIDC-preferred_username"
        },
        {
          "type": "OIDC-projects"
        }
      ]
    }
  ]
}
{% endhighlight %}

These extra fields can also contain tokens like "{0}", so they can contain
values mapped from claims.

#### Map fields over claim list items

We're still missing the final piece: how to wire in our list of projects such
that, for each item in the list, the "name" attribute of the project in the
claim is mapped to the project name, while the "nickname" is mapped to an extra
field?

To solve this, I updated the mapping engine to support more types of token
placeholders than just "{0}", "{1}", etc. The engine now can support tokens
like "{0[name]}", which tells it:

> Look at the claim referenced in the first slot of my declared 'remotes'.
>
> If the claim is an object, return the 'name' field.
>
> If the claim is a list, return a list of all the 'name' fields for each item
> in the list.
>
> If the claim is neither an object nor a list, or is otherwise malformed,
> return nothing.

If you're into functional programming, this effectively provides a way to
express a map operation, albeit with very limited inputs.

This now (finally) allows us to express our mapping using Keystone's mapping
definition:

<!-- prettier-ignore -->
{% highlight json %}
[
  {
    "local": [
      {
        "user": {
          "name": "{0}"
        }
      },
      {
        "projects": [
          {
            "name": "{2[name]}",
            "extra": {
              "nickname": "{2[nickname]}"
            },
            "roles": [
              {
                "name": "member"
              }
            ]
          }
        ]
      }
    ],
    "remote": [
      {
        "type": "preferred_username"
      },
      {
        "type": "projects"
      }
    ]
  }
]
{% endhighlight %}

**Note**: these lookups don't go any further than one level, so it's not
possible to do like "{0[child][name]}" or something like that. At some point one
has to draw the line!

### OpenID provider discovery

## Additional traps

### Limited OIDC support for rich claims

- had to support multiple login mappings, one for fancy clients and one for stupid ones.
- this also had to be supported in Keycloak ("projects" vs "project_names")

> 278900739 (HEAD -> chameleoncloud/train) Add 'optional' mapping directive for remote maps
> 49cadcbca Map keys on multi-valued direct-maps as list
> 413db3f07 Allow mapping extra project properties
> f6bd00d0d Support applying filters to assertion nested props
> 021f7f999 Support JSON-encoded assertion payloads
> cbb5e69f5 Support for deprovisioning federated assignments
> 30abeced8 Support regexes in whitelists/blacklists
> 990470db4 Support third-party login discovery
> f811daf95 Direct map auto-provision project names and roles
